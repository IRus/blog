---
draft: true
title: "Kotlin vs Java Lambdas"
date: 2018-03-30
categories:
  - Kotlin
---

С приходом Java 8 у разработчиков на Java появилась возможность заменить ужасные анонимные классы, на прекрасные лямбды:

```java
run(new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello!");
    }
});

// против короткого:

run(() -> System.out.println("Hello!"));
```

Kotlin в свою очередь значительно улучшил лямбды, но эти улучшения не всем очевидны и многие не подозревают насколько котлиновские лямбды мощнее. Что ж, моя цель показать все отличия и улучшения Kotlin лямбд по сравнению с лямбдами в Java. 

## Новая надежда

Хотя выпуск Java 8 и Java 9 не был таким быстрым как хотелось бы (некоторым), а девятка еще и больно ударила по обратной совместимости, мир увидел Java 10 спустя всего пол года после релиза девятки (конечно не все прошло [гладко](https://bugs.openjdk.java.net/browse/JDK-8199910)). Кажется что Java набирает обороты и становится современным языком, но даже если в Java завезут [Pattern matching](http://openjdk.java.net/jeps/305), то все равно кажется все подобные улучшения несколько половинчаты, к примеру:

```java
List<Человек> человеки = new List<>();
```

Зачем эти пустые меньше-больше `<>`? А затем что до дженериков в Java просто `new List()` был валидной конструкцией, а в Java 5 стал сырым типом (raw type<sup><a name="b1"></a>[1](#a1)</sup>). А т.к. код который работал раньше при добавлении к нему семантики дженериков мог [сломаться](https://stackoverflow.com/questions/4166966/what-is-the-point-of-the-diamond-operator-in-java-7#4167148), то пришлось дописывать diamond оператор в таком случае. Причем только в Java 7 появилась возможность опускать тип в инициализаторе (т.е. тот самый diamond оператор). Java 5 и Java 6 были ужасны в плане количества кода:

```java
List<Человек> человеки = new List<Человек>();
```

И в Java во многом создает такие частичные решения:

```java
final var человеки = new List<Человек>();
```

Отлично, с помощью вывода типов избавились от лишних `<>`, но вывод типов работает только для локальных переменных и не для всех инициализаторов, т.е. примерно 30-50% случаев. При этом вместо локаничного `val` приходится писать `final var`, что все еще не подталкивает к написанию полностью immutable кода.

Из свежего можно вспомнить новые factory методы: `List.of`, `Set.of`, `Map.of` – которые создают неизменяемые колекции, но метод `add` присутсвует, а значит вполне вероятно узнать, что тут была неизменяемая коллекция только в runtime;

Все эти кривоватые решения были приняты по причине обратной совместимости, и лямбд это тоже коснулось. Так например доступ к локальным переменным из лямбды так же ограничен как для анонимных классов:

```java
String out = "";

List.of(1, 2, 3).forEach(el -> {
    out += el; // Compile error
});
```

В Kotlin не стали копировать такого рода решения, и лямбды в Kotlin вполне способны редактировать локальные переменные:

```kotlin
var out = ""

arrayOf(1, 2, 3)
    .forEach({ el -> out += el })
```

Смотрите сколько всего интересного произошло не относящегося к лямбдам:

1. Я создал массив (array) с помощью factory метода;
2. Я могу использовать различные функции вроде `filter`/`map`/`forEach`/etc прямо на массиве.

Если же говорить про лямбды, то в Kotlin они выглядят вот так:

`{}` – это простейшая лямбда которая не принимает никаких аргументов, а её возвращаемый тип `Unit`. Вы можете думать о `Unit` как о аналоге `void` из Java (это отдельная тема почему в Kotlin используется именно он). В нотации Kotlin её тип: `() -> Unit`.

Так же как в Java мы можем присвоить лямбду в переменную, и например явно укажем её тип:

```kotlin
val lambda: () -> Unit = {}
```

Естественно лямбды могут принимать один или несколько аргументов и возвращать какое-то значение:

```kotlin
val lambda: (Int) -> String = { i -> i.toString() }
val lambda: (Int, String) -> String = { i, s -> s + i }
```

В случае единственного аргументы (частый случай при работе с коллекциями) можно не указывать имя аргумента, и использовать неявное имя `it`:

```kotlin
val lambda: (Int) -> String = { it.toString() }
```

или в случае с нашим примером:

```kotlin
var out = ""

arrayOf(1, 2, 3)
    .forEach({ out += it })
```

Также у разработчика есть выбор как определить типы аргументов:

```kotlin
val lambda = { i: Int, s: String -> s + i }
```

В данном случае возвращаемый тип `String` будет выведен компилятором.

Вы уже наверно увидели некоторы отличия синтаксиса от Java:

1. Лямбда визуально не разбивается на две части `(a, b) ->` и `{ // code block }`;
2. Из-за записи лямбды вокруг аргументов не нужны круглые скобочки;
3. Частый случай с единственным аргументом не требует явного имени.

Но это только начало, Kotlin позволяет не обрамлять в круглые скобки лямбды которые идут последним аргументом в функции, т.е.:

```kotlin
var out = ""

arrayOf(1, 2, 3)
    .forEach { out += it }
```

Если бы `forEach` например еще какой-то аргумент (например направление обхода) то код выглядел бы так:

```kotlin
var out = ""

arrayOf(1, 2, 3)
    .forEach(BACKWARD) { out += it }
```

Таким образом вот так выглядят различные лямбды на Kotlin:

```kotlin
val lambda: (Int) -> Int = { it * it }
val lambda: (Int) -> Int = { i -> i * i }
val lambda: (Int, Int) -> Int = { a, b -> a * b }
val lambda: (Int, Int) -> Int = { a, b -> 
    println("Method call")
    a * b
}
```

Да, кстати про многострочные лямбды, как видите можно записывать несколько строк внутри блока. В Kotlin в отличии от Java не стали делать чуть другой синтаксис для однострочных и многострочных лямбд, тем самым сохранив консистентность. Причем консистентность не только в колличестве скобочек, но и в том что `return` не нужен, ведь последнее выражение в лямбде и есть её результат.

В Java же царит разнообразие форм:

```java
final Function<Integer, Integer> lambda = i -> i * i;
final Function<Integer, Integer> lambda = (i) -> i * i;
final BiFunction<Integer, Integer, Integer> lambda = (a, b) -> a * b;
final BiFunction<Integer, Integer, Integer> lambda = (a, b) -> {
    System.out.println("Method call");
    return a * b;
};
```

1. То мы ставим скобочки вокруг аргументов, то не ставим;
2. То мы пишем `return` то не пишем;
3. Иногда мы оборачиваем код в `{}`, а иногда нет.

Просто сравните с тем как в Kotlin все единообразно.

Не говоря уже о том что очевидная конструкция в Kotlin:

```kotlin
val lambda: (Int, Int, Int) -> Int = { a, b, c  -> a * b * c }
```

Выражется примерно таким способом из коробки (не ну понятно что каждый может себе написать `TriFunction`, но почему нет в stdlib?) в Java:

```java
final Function<Integer, BiFunction<Integer, Integer, Integer>> lambda = a -> (b, c) -> a * b * c;
final Integer apply = lambda.apply(1).apply(2, 3);
```

Да, кстати, в Kotlin определен оператор `invoke`, поэтому вызов лямбды не отличается от вызова функции:

```kotlin
lambda(1, 2, 3)
```

Таким образом я хочу подвести итог данной части:

**Kotlin имеет более консистентные лямбды, которые проще определять и использовать. Также они имеют больше возможностей (доступ к локальным переменным, единственный аргумент – `it`).**

## Java наносит ответный удар

В Kotlin для определения лямбды используется функциональные типы (вот эти самые: `(Int) -> Int`), в Java – функциональные интерфейсы.

Java 8 сделала хак, вместо того чтобы объявить новую сущность в языке, они переиспользовали существующие концепции. С одной стороны это было вполне оправдано - много существуещего кода который уже не перепишешь (например класс `Thread`) смогли воспользоваться новой фичей. С другой - скорее всего это повлияло например на орграничение по изменению локальных переменных. Да и в целом объеденило две концепции в одной.

Kotlin в свою очередь имеет две отдельные концепции: функциональный тип и интерфейс.

Собственно как и должно быть: интерфейс вы можете только реализовать в виде класса или объекта, а в аргумент функционального типа передавать лямбды.

Мухи отдельно, котлеты отдельно.

Почему так? Я вижу несколько причин:

1. Разделение концепций: зачем смешить разные понятия?;
2. Мультиплатформа: 
    - Это Java такая, а вот TypeScript(JavaScript с типами) например тоже имеет arrow функции, и интерфейсы;
    - И в Kotlin/Native наверняка не захочется смешивать эти два понятия.

Причем для Java Kotlin реализовал SAM конверсии, т.е. используя легаси Java вы можете преобразовывать Java интерфейсы в лямбды, а вот уже Kotlin код не делает так.

И в этом собственно проблема: некоторы Java разработчики привыкли что там где котлеты, там должны быть и мухи.

Команда Kotlin задумалась чтобы добавить такую возможность в язык, и возможно в 1.3/1.4 и в Kotlin мы сможем смешивать котлеты и мух. **Я надеюсь что нет**, но поживем-увидим.

## Скрытые возможности

Если в Java лямбды это просто короткая запись анонимных классов, то в Kotlin лямбды это корневая фича - дающая возможность делать конструкции похожие на языковые фичи, или например писать DSL.

Рассмотрим данный код на Kotlin:

```kotlin
val any = Any()
synchronized(any) {
    // synchronized block
}
```

В Java `synchronized` это ключевое слово, а в Kotlin - нет. Это просто функция которая первым аргументом принимает объект на котором нужно синхронизироваться, а вторым аргументом - блок кода:

```kotlin
public inline fun <R> synchronized(lock: Any, block: () -> R): R {
    // ...
}
```

Вы можете заметить что в Java можно сделать `return` из `synchronized`, но ведь в Kotlin тоже!

Смотрите:




DSL, Functional type with receiver

## Месть invokedynamic

invokedynamic / inline

оптимизации – сделать много вложенных вызовов и сравнить inline с java 
размер итогового класса – сравнить

1. <a name="a1"></a> Кстати в Kotlin нет совсем сырых типов, такие дела. [↵](#b1) 
