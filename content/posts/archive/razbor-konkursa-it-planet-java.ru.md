---
title: "Разбор конкурса IT-Planet. Java."
date: 2014-01-02
categories:
  - Archive
---

_Также у меня есть вопросы по конкурсу "Администрирование Linux", так что если есть желающие, с вашей помощью, разберем и этот конкурс._

Начнем с пробного теста, который состоит из пяти вопросов.

```
// Какая из следующих строк декларирует и инициализирует массив пятью числами?

// Конструкция <b>int [] a;</b> позволяет декларировать массив. Выражение описанное ниже даже не скомпилируется.
int [5] array;

// В стандартной библиотеке нету класса Array.
Array a = new Array(5);

// В данном варианте предпринимается попытка вызвать конструктор у примитивного типа.
int a [] = new int(5);

// Соответственно верный ответ. Декларируем новый массив <b>a</b> и инициализируем его числами.
int [] a = {42, 43, 44, 45, 46};
```

```
// Какая запись описывает объект с нулевой ссылкой?

Object obj = UNKNOWN;

obj : Object = null;

obj : Object = NULL;

// Очевидно единственно верный ответ.
Object obj = null;

Object obj = 0;

Object obj = NULL;
```

```
// Вы должны определить, введена ли в поле графического интерфейса пустая строка.

// Строка считается пустой если она не содержит символов или содержит только пробельные символы.
// Какая строка кода выполняет такие проверки над переменной String fieldValue.
// Считайте, что переменная fieldValue не равна null.

// <b>trim()</b>: Returns a copy of the string, with leading and trailing whitespace omitted.
// Соответственно, убрав лидирующие и замыкающие пробелы, проверяем длину строки.
fieldValue.trim().length() == 0

// Не имеет смысла
fieldValue.trim() == null

// У String нету метода <b>removeWhitespace</b>
fieldValue.removeWhitespace().equals("")

// Т.к. строка с пробелами это пустая строка, то данный способ не удовлетворяет требованиям.
fieldValue.equals("")

// У String нету метода <b>removeWhitespace</b>
fieldValue.removeWhitespace().length() == 0
```

```
// Пусть x = 2, y = 3, z = 4. Какое выражение в результате вернет false?

// !false == true -> true
!(x == y) == (x != z)

// !false && false -> false
!(x == y) && (x == z)

// !true || true -> true
!(x != y) || (x != z)

// !false || false -> true
!(x == y) || (x == z)
```

```
// Какая из строк является валидным вызовом метода main()?

// Кратко - никакая. Сам вопрос оставляет желать лучшего.
// Ну да ладно, имея ученую степень экстрасенса можно предположить:
// Какая из строк является валидным определением метода <b>main</b>?

// Единственно верная сигнатура метода main
public static void main(String args[]);

public static void main();

public static void main(Graphics g);

public static void main(String args);

public static boolean main(String args[]);
```

А теперь переходим к основному тесту состоящим из 30 вопросов.

```
// К чему приведет выполнение следующего кода
int i1 = 5; double i2 = (float) i1;

// Ошибка времени выполнения?

// Верный ответ. Простое приведение типов.
// Выполнится без ошибок?

// Ошибка компиляции?
```

```
// Выберите корректную декларацию метода в интерфейсе

// Корректно.
public double myMethod();

// Не может быть protected
protected void myMethod(double d1);

// Не может быть final
public final double myMethod();

// Не может быть static
static void myMethod(double d1);
```

```
// Какой оператор используется для инвертирования значения переменной типа boolean?

// NOT

// <>

// invert

// Верно.
// !

// ^^
```

```
// Что из ниже перечисленного не является модификатором доступа к классу?

// public и default(без модификатора) часто употребляемые, и тут вопросов не возникает.
public

default

// <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html">Inner</a> классы могут иметь такой модификатор.
private

// Данный модификатор не является модификатором доступа к классу
protected
```

```
// К чему приведет выполнение следующего кода
int a = 9/0;

// Ошибка компиляции DivideByZeroException

// Выполнится без ошибок

// Ошибка времени выполнения
// Да именно так, RuntimeException: "java.lang.ArithmeticException: / by zero".
```

```
// Если класс A реализует интерфейс B

// Очевидно, если речь не идет про абстрактный класс A, то класс A должен реализовывать все методы.
// Класс A должен реализовать все методы интерфейса B

// Класс A может реализовать часть методов интерфейса B
```

```
int x = 256; // К чему приведет вызов метода <b>foo.vopros21(x)</b>?

void vopros21(int z) {
    z = 0;
}

// Так как примитивные типы передаются по значению, а не по ссылке, 
// то этот вариант верен.
x = 256;

x = 0;

// Ошибка компиляции?

// Ошибка времени выполнения?
```

```
// Можно ли с помощью блока try-catch поймать NPE?

// Да можно, но не нужно.
// Да

// Нет
```

```
// Какого типа будет результат выполнения операции x+y?
Short x = 1;
Short y = 1;

Byte

Boolean

Short

// Наши Short'ы <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2">превратятся в int</a>, соответственно int - верный ответ.
int
```

```
// Что произойдет при вызове метода <b>f()</b>?

void f() {
    boolean condition = true;
    try {
        if (condition) {
            throw new NullPointerException("hello world");
        }
    } catch (Exception e) {
        throw new IllegalArgumentException("strange exception");
    } finally {
        System.out.println("All exception are ignored");
    }
}

// Оба эксепшена Runtime - соответственно объявлять ничего не нужно.
// Не скомпилируется: необходимо объявить throws!

// Это как?
// Бросит оба исключения

// Нет, почему читайте дальше.
// Бросит NullPointerException

// Да. Т.к. condition = true, то упадет NPE, который успешно будет отловлен в catch блоке. 
// И в нем уже упадет IllegalArgumentException, который и пойдет выше по стеку.
// Бросит IllegalArgumentException

// Не бросит исключения
```

```
// Eсли программа MyProg.java была удачно скомпилирована и затем вызвана со следующими параметрами из командной строки: 
<b>java Davay do svidaniya</b> 
// какое значение будет у args[2] внутри метода main()?

// В массив <b>args[]</b> будет положены все параметры переданные при запуске программы.
// Элементом под индексом 2 будет <b>svidaniya</b>

// do
// 4
// Davay
// null until a value is assigned
// svidaniya
// 3
```

```
// Dobro и Zlo являются объектами класса Life(). Если выражение Dobro == Zlo возвращает true, то это значит, что:

// Dobro и Zlo ссылают на разные, но идентичные объекты в Куче

// Сравнение объектов с помощью "==" есть сравнение по ссылке. А раз так, то значит Dobro и Zlo есть один и тот же объект.
// Dobro и Zlo ссылаются на один объект в Куче

// Dobro и Zlo ссылаются на разные объекты в Куче и поля объекта Dobro эквивалентны полям объекта Zlo
```

```
В какой коллекции операция удаления первого элемента занимает наименьшее время?

ArrayList

Stack

Vector

LinkedList

// Правильный ответ - LinkedList.
// ArrayList - это обычный массив, поэтому удаление первого элемента в массиве приводит к сдвигу всех последующих влево на одну ячейку.
// Stack - расширяет Vector, а вектор тот же ArrayList, только с синхронизацией.
// В тоже время LinkedList построен на объектах, поэтому удаление первого элемента - это всего лишь смена значения одного поля у объекта LinkedList.
```

```
// Переменная <b>x</b> имеет бинарное значение (1 байт) 10011100. Какое бинарное значение примет z, после следующих операций:
int y = 1 << 7;
int z = x &#038; y;

// Результатом 1 << 7 будет 0b10000000
// Результат побитового "И":
// 10011100
// 10000000
// --------
// 10000000

// Ответ: 0b10000000
```

```
// Что из ниже перечисленного является ключевыми словами языка Java?

// Примитивный тип, думаю можно считать за ключевое слово.
boolean

// Очевидно, ключевое слово.
super

array

protect

// Просто класс, который входит в стандартную библиотеку.
Integer
```

```
// К чему приведет выполнение следующего кода?

Integer x = new Integer(2);
Integer z = new Integer(2);
System.out.println((x==z));

// Ошибка компиляции

// Ошибка времени выполнения

// Так мы сравниваем ссылки на объекты, а x и z это разные объекты - то результат false.
// false

// true
```

```
// Какое из следующих утверждений верное?

// Нет.
// Вызов new Runnable() {public void run() {...}}.run() создаст и запустит новую нить.

// java.lang.Thread - класс
// И java.lang.Thread, и java.lang.Runnable - интерфейсы.

// Внимательно! java.<b>util</b>.Runnable
// java.lang.Thread - класс, java.util.Runnable - интерфейс.

// Правильный ответ.
// Вызов метода java.lang.Object.wait() необходимо "обернуть" в try {} catch (InterrupedException ie) {...}
```

```
// Как получить доступ к i-му элементу аргумента elems следующего метода: void print(Object... elems) {...}

elems(i)

// Правильный ответ.
elems[i]

elems.getElement(i)

elems.get(i)
```

```
// Какой из методов должен быть определен в классе реализующем интерфейс java.lang.Runnable?

void run();

void statr (int priority)

public void start()

// Правильный ответ.
public void run()
```

```
// Мета-аннотация RetentionPolicy.CLASS означает, что

// Я редко пишу, или смотрю исходники анотаций, поэтому я обратился за информацией к <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/RetentionPolicy.html">javadoc'ам</a>:
// Annotations are to be recorded in the class file by the compiler but need not be retained by the VM at run time.
// Значит первый ответ верен.

// аннотация будет записана в class файл, но не должна быть доступна во время выполнения

// аннотация используется на этапе компиляции и должна отбрасываться компилятором

// аннотация не будет записана в class файл и не будет доступна во время выполнения

// аннотация будет записа в class файл и доступна во время выполнения
```

```
// Какие из строк ниже корректны? (выберите две)

// Корректно.
boolean b = true;

// Попытка создать новый экземляр примитивного типа!
int i = new int("42");

// Корректно.
String s = "null";

// byte может содержать в себе данные от -128 до 127.
byte b = 255;
```

```
// Что будет результатом выполнения следующего кода?

public static void main(String[] args) {
    int i = Integer.MAX_VALUE + Integer.MAX_VALUE;
    long l = Integer.MAX_VALUE + Integer.MAX_VALUE;
    System.out.println("i = " + i + ", l = " + l);
}

// Результатом сложения Integer.MAX_VALUE + Integer.MAX_VALUE будет -2, в этом легко убедиться:
// 01111111111111111111111111111111
// 01111111111111111111111111111111
// --------------------------------
// 11111111111111111111111111111110
// 
// И int i и long l будет содержать -2, т.к. сложение производится с аргументами типа int,
// а только потом приводится к типу long
// значит первый ответ верен

// i = -2, l = -2

// i = 4294967294, l = 4294967294

// Будет брошен OutOfMemoryError

// i = 4294967294, l = -2

// i = -2, l = 4294967294
```

```
Класс Files пакета NIO.2 предназначен для:

// Перемещения и копирования файлов и директорий

// удаления файлов

// создания файлов и директорий

// Очевидно последнее
// все перечисленное
```

```
Какой оператор используется для сравнения двух значений в java

equal

=

// Правильно
==
```

```
Какая из коллекций не гарантирует порядок расположения элементов, но гарантирует уникальность каждого.

ArrayList

LinkedList

// Очевидно коллекции построенные на хэшах удовлетворяют требованиям.
HashSet

```

```
// Как иначе называется переменная класса в Java

// Верный ответ. 
// Статическое поле

// Нестатическое поле

// Константа
```

```
// К чему приведет выполнение следующего кода?

class A {public static void main(String[] args) {A a = new B();}}
class B extends A {}

// Если классы лежат в своих файлах, то выполнится без ошибок. В противном случае - ошибка компиляции.

// Ошибка компиляции

// Выполнится без ошибок

// Ошибка времени выполнения
```

```
// Какая из коллекций не допускает дубликаты?

// Данная не допускает.
HashSet

ArrayDeque

ArrayList

LinkedList
```
